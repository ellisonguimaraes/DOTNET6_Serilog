# Serilog

O **Serilog** √© um framework que fornece registro de diagn√≥stico ou *Logging* para arquivos, db, console e em outros formatos, facilitando a cria√ß√£o de registros de logs; √© f√°cil de configurar, tem uma API limpa e √© port√°til entre as plataformas .NET.

Podemos instalar o Serilog no .NET 6 via NuGet com `dotnet add package Serilog.AspNetCore`. Por√©m, precisamos de alguns pacotes chamados de coletores ou **Sinks**: os coletores s√£o as configura√ß√µes do local de armazenamento dos logs. Veja alguns **Sinks**:

- `dotnet add package Serilog.Sinks.Console` para exibir o *log* no console;
- `dotnet add package Serilog.Sinks.File` para salvar em um arquivo;
- `dotnet add package Serilog.Sinks.Seq` para utilizar o **Seq**;
- `dotnet add package Serilog.Sinks.MSSqlServer` para salvar no banco de dados SQLServer.

O desenvolvedor precisa incluir todos os pacotes de **Sinks** que deseja utilizar, lembrando, que podemos registrar o log em mais de um provedor ao mesmo tempo.

> üí° Nesse link podemos ver todos os **Sinks** dispon√≠veis pelo **Serilog**: [https://github.com/serilog/serilog/wiki/Provided-Sinks](https://github.com/serilog/serilog/wiki/Provided-Sinks).

> No projeto **SerilogAPI** cont√©m as configura√ß√µes do **Serilog** utilizando o `Program.cs`. J√° no projeto **SerilogAPIappsettings** cont√©m as configura√ß√µes sendo feitas atrav√©s do `appsettings.json`.



---

# 1. N√≠veis de Log

O **Serilog** cont√©m os seguintes n√≠veis de log, em ordem de menos importante para o mais importante:

1. **Verbose**: √â o mais ruidoso, raramente (ou nunca) √© habilitado para um aplicativo de produ√ß√£o. Descreve informa√ß√µes detalhadas de debug e rastreamento;
2. **Debug**: descreve informa√ß√µes de debug e fluxo da aplica√ß√£o (eventos internos). √â mais usado para eventos internos do sistema que n√£o s√£o necessariamente observ√°veis de fora, mas s√£o √∫teis para determinar como algo aconteceu;
3. **Information**: registra eventos de interesse e relev√¢ncia (fun√ß√µes do sistema). Descrevem coisas que acontecem no sistema que correspondem √†s suas responsabilidades e fun√ß√µes. Geralmente, essas s√£o as a√ß√µes observ√°veis que o sistema pode realizar;
4. **Warning**: registra informa√ß√µes de poss√≠veis problemas e comportamentos inesperados;
5. **Error**: registra informa√ß√µes de falha de qualquer tipo; usado em exce√ß√µes;
6. **Fatal**: registra erros cr√≠ticos que comprometam a aplica√ß√£o de forma completa.

---

# 2. Configurando o Serilog ao projeto

Para utilizar o **Serilog** no .NET 6 devemos fazer a inclus√£o/configura√ß√£o no **Program.cs** do projeto.

- Inicialmente devemos excluir todos os provedores existentes de *log*, e isso pode ser feito com o comando `builder.Logging.ClearProviders()`;
- Agora partiremos para configurar o **Serilog** criando uma inst√¢ncia de `LoggerConfiguration()`. √â aqui que ser√£o feitas as configura√ß√µes das caracter√≠sticas de *log*. Veremos no bloco de c√≥digo abaixo como fica essa configura√ß√£o;
- Ap√≥s criar a inst√¢ncia de `LoggerConfiguration`, devemos incluir o **Serilog** como provedor de *logging* com o comando `builder.Logging.AddSerilog(logger)`, sendo `logger` a inst√¢ncia criada acima.

Veja as configura√ß√µes:

```csharp
using Serilog;

var builder = WebApplication.CreateBuilder(args);

// Remove default logging providers
builder.Logging.ClearProviders();

// Serilog configuration		
var logger = new LoggerConfiguration()
    .WriteTo.Console()
    .WriteTo.File("logs/log.txt", rollingInterval: RollingInterval.Day)
    .WriteTo.Seq("http://localhost:5341/")
    .CreateLogger();

// Register Serilog
builder.Logging.AddSerilog(logger);

// Add Controllers
builder.Services.AddControllers();

var app = builder.Build();

// Map Controllers
app.MapControllers();

app.MapGet("/v1/minimalapi", (ILoggerFactory loggerFactory) => {
    var logger = loggerFactory.CreateLogger("MinimalAPI Log");
    logger.LogInformation("Entrou na rota MinimalAPI /v1/minimalapi");
});

app.Run();
```

> üí° **IMPORTANTE!**
> √â preciso excluir em `appsettings.json` as configura√ß√µes de *logging* que vem por padr√£o.

## 2.1. Configurando

Ao criar a inst√¢ncia de `LoggerConfiguration` existem algumas configura√ß√µes a serem feitas para possibilitar o funcionamento do **Serilog**:

1. A principal delas √© o `CreateLogger()` que a partir desse momento que √© criado o *logger*. 

2. Al√©m dela temos o `WriteTo` que ser√£o os **Sinks** configurados para exibir o **log**. Nesse projeto:
    - √â configurado o *log* para aparecer no console com `.WriteTo.Console()`;
    
    - O `.WriteTo.File("filepath/file.txt", rollingInterval: RollingInterval.Day)` tamb√©m √© configurado, para exibir em um arquivo. Nele √© poss√≠vel ainda:
        - Informar se deseja dividir o *log* (em v√°rios arquivos) em determinada quantidade de tempo com `rollingInterval: RollingInterval.Day` onde as alternativas s√£o:
            - `RollingInterval.Day`: para dividir o *log* por **dia**, ou seja, isso significa que para cada dia haver√° um arquivo de *log;*
            - `RollingInterval.Mounth`: para dividir o *log* por **m√™s**;
            - `RollingInterval.Year`: para dividir o *log* por **ano**;
            - `RollingInterval.Minute`: para dividir o *log* por **minuto**;
            - `RollingInterval.Hour`: para dividir o *log* por **hora**.
        - Podemos tamb√©m definir o formato do *log* com `outputTemplate`. Por exemplo:
        
        ```csharp
        .WriteTo.File("logs/log.txt", outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}");
        ```
        
    - Tamb√©m configuramos para que possamos visualizar o *log* pelo **Seq** com o comando `.WriteTo.Seq("serverurl:port")`.
      
        
        
        ![Untitled](assets/Untitled.png)
        
        
    
3. O **Serilog** implementa o conceito de um **‚Äún√≠vel m√≠nimo‚Äù** para processamento de eventos de *log*. O¬†`MinimumLevel` de configura√ß√£o prev√™ que um dos n√≠veis de evento de *log* seja especificado como m√≠nimo.¬†Quando definido, os eventos de *log* com n√≠vel especificado e superior a ele ser√£o processados e, por fim, gravados no console. Veja o exemplo abaixo:
   
    ```csharp
    var logger = new LoggerConfiguration()
        .MinimumLevel.Debug()
        .WriteTo.Console()
        .WriteTo.File("logs/log.txt", rollingInterval: RollingInterval.Day)
        .WriteTo.Seq("http://localhost:5341/")
        .CreateLogger();
    ```
    
    Quando definido a configura√ß√£o acima, o level m√≠nimo de visualiza√ß√£o dos *logs* √© o **Debug e** **todos os leveis acima de Debug** tamb√©m ser√£o visualizados: √© poss√≠vel observar pela palavra **DBG** (de debug) e **INF** (de information) ao lado esquerdo do *log*:
    
    
    
    ![Untitled](assets/Untitled%201.png)
    
    
    
    A ordem de prioridade/n√≠veis do tipo de *log* est√£o especificados no t√≥pico 1. Veja agora quando `MinimumLevel` √© `Verbose`:
    
    
    
    ![Untitled](assets/Untitled%202.png)
    
    
    
    No modo **Verbose** exibe muito mais ru√≠dos. A cada requisi√ß√£o exibe MUITOS *logs*.
    
    > üí° Por padr√£o, se `MinimumLevel` n√£o for especificado, √© considerado `Information`.
    
    > üí° Podemos ainda definir um n√≠vel m√≠nimo de logs para cada **Sinks** espec√≠ficamente com base no n√≠vel m√≠nimo padr√£o: definindo por exemplo que no **Console** sejam armazenados com `MinimumLevel` igual a `Debug`, mas no **File** restringimos o `MinimumLevel` igual a `Information`. Vejamos as configura√ß√µes a seguir:
    >
    >
    > ```csharp
    > // Serilog configuration		
    > var logger = new LoggerConfiguration()
    >     .MinimumLevel.Debug()
    >     .WriteTo.Console()
    >     .WriteTo.File("logs/log.txt", rollingInterval: RollingInterval.Day, 
    > 																	restrictedToMinimumLevel: LogEventLevel.Information)
    >     .WriteTo.Seq("http://localhost:5341/")
    >     .CreateLogger();
    > ```
    >
    > Definimos acima que o padr√£o ser√° `Debug` e que o **File** em espec√≠fico ter√° a atribui√ß√£o de `restrictedToMinimumLevel` para `LogEventLevel.Information`. Com isso, todos os **sinks** que n√£o cont√©m a especifica√ß√£o de `restrictedToMinimumLevel` ter√£o o n√≠vel de *log* padr√£o. Com isso, o **Console** exibir√° **DBG** e **INF**:
    >
    > 
    >
    > ![Untitled](assets/Untitled%203.png)
    >
    > 
    >
    > Enquanto o **File** exibir√° somente **INF**:
    >
    > 
    >
    > ![Untitled](assets/Untitled%204.png)
    
    
    

## 2.2. Configurando atrav√©s do `appsettings.json`

Na inst√¢ncia do `LoggerConfiguration()` √© poss√≠vel informar que as configura√ß√µes est√£o no arquivo `appsettings.json`, atrav√©s do comando `.ReadFrom.Configuration()` passando o arquivo de configura√ß√£o que fica em `builder.Configuration`. Veja a seguir:

```csharp
using Serilog;

var builder = WebApplication.CreateBuilder(args);

builder.Logging.ClearProviders();

var logger = new LoggerConfiguration() 
    .ReadFrom.Configuration(builder.Configuration)
    .CreateLogger();

builder.Logging.AddSerilog(logger);

var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

Veja no `appsettings.json` como essas configura√ß√µes s√£o inseridas:

```json
{
	"Serilog": {
		"MinimumLevel": { 
			"Default": "Debug", 
			"Override": {
				"System": "Debug", 
				"Microsoft": "Debug" 
			}
		},
		"WriteTo": [
			{
				"Name": "Seq", 
				"Args": { 
					"serverUrl": "http://localhost:5341/", 
					"apiKey": "WZRuiAk90KZ42XPkArea" 
				}
			},
			{
				"Name": "Console" 
			},
			{
				"Name": "File", 
				"Args": { 
					"path": "logs/log.txt", 
					"restrictedToMinimumLevel": "Information", 
					"rollingInterval": "Day" }
				}
		]
	}
}
```

Outras configura√ß√µes tamb√©m s√£o poss√≠veis: [https://github.com/serilog/serilog-settings-configuration](https://github.com/serilog/serilog-settings-configuration). 

## 2.3. Enrichers (Enriquecedores)

No **Serilog** existe os **Enrichers**, que assim como o pr√≥prio termo diz, s√£o enriquecedores. Eles s√£o utilizados para enriquecer os *logs*. Existem alguns pacotes como:

- `Serilog.Enrichers.Environment` que permite adicionamos informa√ß√µes aos *logs*, como:
  
    
    
    <img src="assets/Untitled%205.png" alt="Untitled" style="zoom: 67%;" />
    
    
    
    - `WithMachineName()`: que disponibiliza ao *log* o nome da m√°quina.
    - `WithProperty()`: que possibilita a cria√ß√£o de qualquer propriedade. √â muito √∫til para especificar qual a aplica√ß√£o no `Seq`, como no print acima que usamos `WithProperty("Application", "ApiSerilogAppSettingsTest")`.
    - `WithEnvironmentUserName()`: que disponibiliza ao *log* o nome do usu√°rio.
    - `WithEnvironmentName()`: que disponibiliza ao *log* o nome do ambiente de desenvolvimento (*development*, *staging*, etc.).
    
- `Serilog.Exceptions` que adiciona informa√ß√µes estruturadas as exce√ß√µes com `WithExceptionDetails()`;

- `Serilog.Enrichers.ClientInfo` que permite enriquecer o *log* com informa√ß√µes de:
    
    - **IP** com `WithClientIp()`;
    - **UserAgent** com `WithClientAgent()`.
    
- `Serilog.Enrichers.Process`¬†que permite obter o *id* do processo com `WithProcessId()`;

- `Serilog.Enrichers.Thread`¬†que permite obter o *id* da *thread* com¬†`WithThreadId()`;

Veja como s√£o inseridos as informa√ß√µes dos ***enrichers***:

```csharp
using Serilog;
using Serilog.Exceptions;

var builder = WebApplication.CreateBuilder(args);

builder.Logging.ClearProviders();

var logger = new LoggerConfiguration() 
    .ReadFrom.Configuration(builder.Configuration)
    .Enrich.WithMachineName()
    .Enrich.WithEnvironmentUserName()
    .Enrich.WithEnvironmentName()
    .Enrich.WithClientIp()
    .Enrich.WithClientAgent()
    .Enrich.WithExceptionDetails()
    .Enrich.WithProperty("Application", "ApiSerilogAppSettingsTest")
    .CreateLogger();

builder.Logging.AddSerilog(logger);

var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

Ou podemos inserir todas as configura√ß√µes no pr√≥prio `appsettings.json`:

```json
{
	"Serilog": {
		"MinimumLevel": { 
			"Default": "Debug", 
			"Override": {
				"System": "Debug", 
				"Microsoft": "Debug" 
			}
		},
		"WriteTo": [
			{
				"Name": "Seq", 
				"Args": { 
					"serverUrl": "http://localhost:5341/", 
					"apiKey": "WZRuiAk90KZ42XPkArea" 
				}
			},
			{
				"Name": "Console" 
			},
			{
				"Name": "File", 
				"Args": { 
					"path": "logs/log.txt", 
					"restrictedToMinimumLevel": "Information", 
					"rollingInterval": "Day" }
				}
		],
		"Enrich": [ 
			"WithMachineName", 
			"WithEnvironmentUserName", 
			"WithEnvironmentName", 
			"WithClientIp", 
			"WithClientAgent", 
			"WithExceptionDetails"
		],
		"Properties":{
			"Application": "MyApiAppSettingsTest"
		}
	}
}
```

> üí° Para mais informa√ß√µes sobre os ***enrichers*** acessar o Github: [https://github.com/serilog/serilog/wiki/Enrichment](https://github.com/serilog/serilog/wiki/Enrichment).



---

# 3. Registrando Log

## 3.1. Atrav√©s do Controller

### 3.1.1. Usando `ILogger`

Para registrar um *log atrav√©s* de um *controller* devemos receber via inje√ß√£o de depend√™ncia a abstra√ß√£o `ILogger<Controller>` informando o *controller* em que est√°. Veja por exemplo o c√≥digo abaixo:

```csharp
using Microsoft.AspNetCore.Mvc;

namespace Controllers;

[ApiController]
[Route("v1/[controller]")]
public class LoggerController : ControllerBase
{
    private readonly ILogger<LoggerController> _logger;

    public LoggerController(ILogger<LoggerController> logger)
    {
        _logger = logger;
    }

    [HttpGet]
    public IActionResult AddLog()
    {
        _logger.LogInformation("Entrou na AddLog do LoggerController");
        return Ok();
    }
}
```

Recebemos no construtor o `ILogger<LoggerController>` e atribuimos sua refer√™ncia a uma vari√°vel local para que possa ser usada nos m√©todos/rotas.  

### 3.1.2. Usando `ILoggerFactory`

Podemos tamb√©m registrar em um *controller* com a DI da abstra√ß√£o `ILoggerFactory`. Usando dentro do construtor o `.CreateLogger<Controller>()` ou `.CreateLogger("Context")` para obter o `ILogger`.

```csharp
using Microsoft.AspNetCore.Mvc;

namespace Controllers;

[ApiController]
[Route("v1/[controller]")]
public class FactoryController : ControllerBase
{
    private readonly ILogger _logger;
    // ou private readonly ILogger<FactoryController> _logger;

    public FactoryController(ILoggerFactory loggerFactory)
    {
        _logger = loggerFactory.CreateLogger<FactoryController>();
        // ou _logger = loggerFactory.CreateLogger("LoggerController");
    }

    [HttpGet]
    public IActionResult AddLog()
    {
        _logger.LogInformation("Entrou na AddLog do FactoryController");
        return Ok();
    }
}
```

Al√©m disso, atribuimos ao atributo local `_logger`, onde pode admitir o tipo `ILogger` (mais gen√©rico) ou `ILogger<LoggerController>`.

> üí° Com o `ILogger` identificando o *controller* respons√°vel, as informa√ß√µes de *SourceContext* e *ActionName* √© *preenchido* automaticamente no **Seq**. Veja abaixo:
>
> ![Untitled](assets/Untitled%206.png)
>
> Isso n√£o ocorre quando criamos o log atrav√©s das rotas de Minimal API.

## 3.2. Atrav√©s da Minimal API (Program)

Como a Minimal API n√£o est√° dentro de nenhum contexto (*controller*) n√£o podemos utilizar as interfaces `ILogger` (tanto de **Serilog**, quanto de ***Microsoft*.*Extensions*.*Logging***). Devido a isso utilizamos a interface `ILoggerFactory` como no t√≥pico 3.1.2. Veja abaixo:

```csharp
app.MapGet("/v1/minimalapi", (ILoggerFactory loggerFactory) => {
    var logger = loggerFactory.CreateLogger("MinimalAPI Log");
    logger.LogInformation("Entrou na rota MinimalAPI /v1/minimalapi");
});
```

Criando um *log* do tipo `ILogger` com `CreateLogger("context")` informando o contexto. 

> üí° Dessa forma, as informa√ß√µes exibidas no **Seq** s√£o mais an√™micas que do modo anterior, j√° que n√£o √© identificado um *controller*. Veja abaixo:
>
> <img src="assets/Untitled%207.png" alt="Untitled" style="zoom:67%;" />

